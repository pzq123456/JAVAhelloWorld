# 复习
## 第3章 面向对象基础
### 1.类和对象
- `面向对象的三个基本特征是`：封装、继承和多态，这几个特征的理解:
- * 封装：访问修饰符限制访问+对外提供公共方法访问变量
- * 继承：
- * 多态：
- `Java类的基本结构`:
```java
    修饰符 class 类名{
        //属性
        //构造方法
        //方法
    }
```
- `类和对象的关系`：类是对象的类型，对象是类的实例。
- 什么是引用类型？引用类型变量的存放位置？new的含义？
- * Java 中除了基本数据类型外都是引用类型。
- * 通过引用操作对象
- * 引用类型变量的存放位置：栈内存区
- * new的含义：开辟对象存储空间，对象保存在堆内存区。
- * 通过赋值将`堆空间`中的`首地址`赋给栈空间中的对象变量（引用变量），让它们建立起引用关系。
- * 访问类中的数据成员：对象变量.数据成员变量名
- * 调用类中的方法成员：对象变量.方法名(实参列表)

- 实例变量和类变量（静态变量）的区别？如何对他们进行访问？
- 实例变量：没有 static 关键字修饰的成员变量，不同实例的值可能不同。访问方法：实例名.成员变量；
- 静态变量（类变量）：用 static 修饰，整个类中共享一个值，类初始化时就被赋值。访问方法：类名\实例名.
- 静态变量；


- 实例方法和类方法（静态方法）的区别？如何对他们进行访问？
- 实例方法：无 static 关键字修饰，表示特定对象的功能和行为。

- 什么是`构造方法`，构造方法有什么特点？
- * 描述如何对对象进行初始化的方法，构造方法的名称与类名相同
- * 特点：没有返回值，不能使用 void 修饰，不能使用 return 语句返回值，可以重载，如果没有定义构造方法，系统会默认提供一个无参的构造方法。
- * 构造方法重载：
- - * 在同一个类中，可以定义多个构造方法，只要它们的参数列表不同即可。
- - * `this`关键字可以调用另一个构造方法。(`this`关键字必须位于构造方法的第一句。)

- 什么是`方法重载`，方法重载有什么特点？
- * 一个类中有两个及以上参数不同的重名方法，与返回值及访问修饰符无关。
- * 特点：一个类中，重名，参数列表不同，与返回值及访问修饰符无关

- 构造方法的重载（使对象初始化多样化）
- `this关键字`
- this关键字指向的是当前对象的引用
- this.属性名:指的是访问当前对象中的成员变量，用来区分成员变量和局部变量
- this(参数):在构造方法中使用this关键字调用另一个构造方法（重载构造方法）。用this调用另一个构造方法时，必须位于构造方法的第一句
- this关键字的使用场景：
- * 在构造方法中调用另一个构造方法
- * 在方法中调用本类中的其他方法

- JVM 内存分配策略表
| 内存区域 | 作用 |
| --- | --- |
|heap(堆) | 存放 new 动态创建的对象，JVM 不定时查看这个对象是否还有引用指向它，如果没有，就会被垃圾回收器回收。 |
|stack(栈) | 存放局部变量，引用变量，具体方法执行结束之后，这些变量就会被释放。 |
|data segment(数据段) | 静态变量字符串常量，不释放。 |
|code segment(代码段) | 存放代码，多个对象可共享一个代码段。 |

### 2.包
- 声明包：package 包名；
- 在每个源文件中只能有一个包的声明语句，该语句放在源文件的`第一行`。
```java
    package com.itheima;
    public class Demo{
        public static void main(String[] args){
            System.out.println("Hello World!");
        }
    }
```
- 类中可以直接使用其所在包的其他类。类中可以使用其它包中的所有public类。
- 导入包：import 包名.类名|*

### 3. 继承 
-	父类对象和子类对象的关系：父类是所有子类公共属性及方法的集合，子类是父类的特殊化。子类对象与父类对象存在“是一个”的关系。

-	访问权限控制：public > protected > 默认 > private
- * `public` 可以在任何地方被访问 
- * `默认` 只能在同一个包中被访问 
- * `protected` 只能在同一个包中或者子类中被访问 
- * `private` 只能在本类中被访问
    | 修饰符 | 类内部 | 同一个包 | 子类 | 其他包 |
    | --- | --- | --- | --- | --- |
    | public | Y | Y | Y | Y |
    | protected | Y | Y | Y | N |
    | 默认 | Y | Y | N | N |
    | private | Y | N | N | N |


    |/|private|default|protected|public|
    |---|---|---|---|---|
    |同一个类|是|是|是|是|
    |同一个包中子类|否|是|是|是|
    |同一个包中非子类|否|是|是|是|
    |不同包中的子类|否|否|是|是|
    |不同包中的非子类|否|否|否|是|



-	什么是方法的重写，与方法的重载有什么区别？
-	方法重写：子类对从父类继承的方法进行重新定义方法体，子类对象调用该方法时，会调用子类中的方法体。
-	方法重写的要求 “同名同参数，类型小的权限大”
-	* 子类重写的方法的**方法名、参数列表、返回值类型**必须与父类被重写的方法相同。
-	* 子类重写的方法的访问权限不能低于父类被重写的方法的访问权限。（即子类不能采取更严格的访问权限）
-	* 子类重写的方法不能抛出比父类被重写的方法更多的异常。
-	* 子类重写的方法不能是父类被重写的方法的 static 方法、final 方法、private 方法。
-	* 子类的返回值类型比父类方法的返回值类型更严格，即子类的返回值类型必须是父类返回值类型的子类。

-	Super关键字，用法：
-	super.属性名 ：引用父类的属性（前提是父类中的该属性不能是private私有的）
-	super.方法名 ：调用父类的普通方法
-	super(参数)；：调用父类中某个构造方法（该语句必须作为子类构造方法中的`第一条语句`）
-	子类的构造方法
-	子类的构造方法中必须要调用父类的构造方法
-	当父类有无参构造方法时（显示或隐式），子类的有参和无参构造方法都默认调用父类的无参构造方法
-	当父类只有有参构造方法时，子类可以有有参和无参构造方法，但是子类的构造方法必须显式调用父类的有参构造方法。
-	对象转型
-	向上转型（upcasting）：子类对象转换成父类对象，不用显示类型转换
-	向下转型（downcasting）：父类对象转换成子类对象，**需用显示类型转换**，且需要父类对象指向的是子类对象
-	instanceof运算符 “对象 instanceof 类型” 表示 判断对象是否是该类型的实例，返回值是boolean类型。

-	Object类是所有类的父类，所有类都继承了Object类的方法。
-	toString()方法：如何重写toString()方法使其返回某类对象的属性信息。
- 重写toString()方法：
    - ```java
        public String toString(){
            return "姓名：" + this.name + "，年龄：" + this.age;
        }
        ```
-	equals()方法：如何重写equals()方法使某个类的两个对象按照自己的标准判断是否相等。
- 重写equals()方法： 参数必须是Object类型，返回值必须是boolean类型，否则就是重载。
    - ```java
        public boolean equals(Object obj){
            if(this == obj){
                return true;
            }
            if(obj == null){
                return false;
            }
            if(this.getClass() != obj.getClass()){
                return false;
            }
            Student s = (Student)obj;
            return this.name.equals(s.name) && this.age == s.age;
        }
        ```
-	final关键字
-	修饰类时类不能被继承
-	修饰方法时方法不能被重写
-	修饰变量时变量不能被重新赋值

4.	多态
- 多态的概念:多态性是指不同类的对象可以使`用相同的方法`，但这些对象调用同一方法时的行为可以有所不同。例如：所有的`Object`类的对象都可以调用`toString()`方法，但具体实现可以不同。
- 多态的实现方式:
- * 父类对象和从相同的父类派生出来的多个子类的对象，可被当作同种类型的对象对待（子类的对象可以当父类的对象来用）
- * 实现同一接口不同类型的对象，可被当作同一种类型的对象对待

- 多态的实现原理:
- * 多态的实现原理是：当父类引用指向子类对象时，通过父类引用调用子类重写的方法时，会调用子类重写的方法。
- * 当父类引用指向子类对象时，通过父类引用调用子类没有重写的方法时，会调用父类的方法。
- * 当父类引用指向子类对象时，通过父类引用调用父类的方法时，会调用父类的方法。
- * 当父类引用指向子类对象时，通过子类引用调用子类重写的方法时，会调用子类重写的方法。
- * 当父类引用指向子类对象时，通过子类引用调用子类没有重写的方法时，会调用父类的方法。

- `Java`中的多态性
- * 静态多态性：方法的重载。程序在编译时就能确定调用哪个方法。
- * 动态多态性：方法的重写。在运行时同样的方法调用，会根据对象的不同而调用不同的方法。

- 方法绑定: 建立方法调用和方法体的对应关系的过程。
- 静态绑定（早绑定、先期绑定）: 在编译时就能确定方法调用的过程。
- 动态绑定（晚绑定、后期绑定）: 在运行时才能确定方法调用的过程。

- 多态存在的条件:
- * 要有`继承`
- * 要有方法的`重写`
- * 使用父`类引用`指向子类对象 

- 抽象方法是一种没有实现的方法，只有方法的声明，没有方法体。抽象类是一种特殊的类，它的方法不全是抽象方法，也可以包含具体的方法。抽象类不能被实例化，只能被继承。
- 示例代码:
```java
public abstract class Animal{
    private String name;        // 属性
    public Animal(String name){ // 构造方法
        this.name = name;
    }
    public abstract void eat(); // 抽象方法
}
```

5.	数组
-	数组的创建
-	数组的初始化
-	静态初始化
-	动态初始化
-	一维数组的使用
-	通过数组下标引用数组元素
-	数组的长度属性：length
-	数组的遍历
-	普通for循环
-	增强for循环

6.	接口
-	接口的概念和特点: 接口是一种功能上的抽象，是一种规范，是一种标准
-	接口中定义了多个类共同的行为规范，接口中定义的抽象方法是与外部交流的通道
-	接口可以建立类与类之间的协议
-	可以变通的实现多继承，即一个接口可以继承多个，一个类可以实现多个接口

-	接口的定义
-	接口可以继承多个父接口
-	接口中的方法都是抽象方法
-	接口中可以包含基本数据类型的数据成员，但它们都是默认为static和final
```java
// 接口的定义
public interface Comparable{
    public int compareTo(Object obj);
}
```
-	接口的使用
-	类实现接口
-	类中重写接口中的抽象方法
-	如何重写Comparable接口中的compareTo()方法来按自己的标准比较两个对象的大小，从而可以通过调用Arrays类中sort()方法对该类数组进行排序。
```java
public class Student implements Comparable{
    // 实现Comparable接口
    private String name;
    private int age;
    public Student(String name, int age){
        this.name = name;
        this.age = age;
    }
    public String getName(){
        return name;
    }
    public int getAge(){
        return age;
    }
    // 重写Comparable接口中的compareTo()方法
    @Override
    public int compareTo(Object obj){
        if(obj instanceof Student){
            Student s = (Student)obj;
            if(this.age > s.age){
                return 1;
            }else if(this.age < s.age){
                return -1;
            }else{
                return 0;
            }
        }
        return 0;
    }
}
```
-	接口与抽象类的相似处和区别

## 第4章 常用类

1.	String类
-	特点：String类表示了定长、不可变的字符序列
-	用String定义一个字符串常用的两种方法：
-	String str=“hello world”;
-	String str=new String (“hello world”); 
这两种方法有什么区别？ 
-	String类的常用方法：length()、equals()、split() 等
-	String类对equals方法进行了重写，比较的是两个字符串对象的内容是否相同

2.	StringBuffer类
-	常用方法：append()、delete()、insert()、replace()
-	特点：StringBuffer对象调用以上方法后，返回值都是当前对象自己，所以说StringBuffer它可以改变字符序列的长度和内容。
-	StringBuffer没有重写equals()方法

3.	包装类 
-	什么是包装类，包装类有哪些？
-	什么是自动装箱和自动拆箱，举例说明。

4.	其他类：Scanner、Math

第5章 容器（集合）

1.	Collection接口
-	有三个子接口（List接口、Set接口、Queue接口）
-	常用方法：size() , add(Object obj),  remove(Object obj),  iterator ()

2.	List接口：
-	特点：按照一定次序（对象进入的顺序）排列的对象集，对象之间有次序关系（即元素有序号），对象可以重复。
-	常用方法： add(int index, E element)，get(int index)  ，remove(int index)  
-	实现类：ArrayList类，该类集合可以用普通for循环、增强for循环、迭代器遍历
           
3.	Set接
-	特点：对象唯一，不重复；元素没有顺序（无序的含义：不是按添加的顺序）。
-	实现类：
-	HashSet  ：如果该种集合放的是自定义类对象，则该类中需重写hashCode和equals方法来确定两个对象是否相等以避免存入相同对象。
-	TreeSet类：自动升序排，因此该类集合中的对象需具有比较大小的能力，如果集合中的对象是自定义类对象则该类除了重写equals方法还需实现Comparable接口并重写其中的compareTo方法。

4.	Map接口
-	特点：一群成对的对象集，这些对象各自保持着“键-值”（key-value）对应关系，键无序不允许重复，值无序可重复。（无序的含义：不是按添加的顺序）
-	常用方法：put(K key,V value)、get(Object key)、remove(Object key)、keySet()、values()
-	实现类：
-	HashMap类：键如果是自定义类对象，则该类中需重写hashCode和equals方法来确定两个键是否相等以避免存入相同对象。
-	TreeMap类：键自动升序排。键如果是自定义类对象，则该类除了重写equals方法还需实现Comparable接口并重写其中的compareTo方法。

5.	Iterator接口
-	iterator方法：Collection接口的集合都有一个iterator方法。该方法返回一个实现了Iterator接口的迭代器对象。
-	迭代器的三个方法：hasNext()、next()、remove()
-	如何定义某个集合的迭代器对象，如何通过这个迭代器对象遍历该集合。

在 Java 语言中，那些包是编译器自动导入的？
java.lang 包

有以下方法的定义，该方法的返回类型应为什么？
返回类型 method(int x, double y)
{
return (short)x/y*2;
}
short

java 中字符类型的变量默认为什么值？
'\u0000'